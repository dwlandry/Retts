<!DOCTYPE html>

<html lang="en">
<head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-GKBZZ2D326"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-GKBZZ2D326');
</script>
<!-- GoatCounter analytics -->
<script data-goatcounter="https://dwlandry.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Raiderettes Competition Day Schedule</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Outfit:wght@300;400;500;600;700&family=Dancing+Script:wght@700&display=swap" rel="stylesheet">
<style>
  :root {
    --blue: #729bd1;
    --red: #c8102e;
    --dark: #0a1628;
    --mid: #132744;
  }

* { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }

body {
min-height: 100vh;
min-height: 100dvh;
background: linear-gradient(165deg, #0a1628 0%, #132744 30%, #1a3460 60%, #0d1f3d 100%);
font-family: ‚ÄòOutfit‚Äô, ‚ÄòSegoe UI‚Äô, system-ui, sans-serif;
color: #fff;
overflow-x: hidden;
-webkit-font-smoothing: antialiased;
}

/* ‚îÄ‚îÄ Stars ‚îÄ‚îÄ */
.star {
position: fixed;
width: 5px; height: 5px;
border-radius: 50%;
background: rgba(255,255,255,.65);
animation: twinkle var(--dur) ease-in-out infinite;
animation-delay: var(--delay);
pointer-events: none;
z-index: 0;
}
@keyframes twinkle {
0%,100% { opacity:.15; transform:scale(.7); }
50%     { opacity:1;   transform:scale(1.4); }
}

/* ‚îÄ‚îÄ Floating emoji ‚îÄ‚îÄ */
.floater {
position: fixed;
font-size: 22px;
opacity: .12;
pointer-events: none;
z-index: 0;
animation: floatUp var(--dur) ease-in-out infinite;
animation-delay: var(--delay);
}
@keyframes floatUp {
0%,100% { transform:translateY(0) rotate(0deg); }
50%     { transform:translateY(-35px) rotate(12deg); }
}

/* ‚îÄ‚îÄ Top stripe ‚îÄ‚îÄ */
.stripe { height:4px; background:linear-gradient(90deg,#c8102e,#729bd1,#c8102e,#729bd1,#c8102e); position:relative; z-index:1; }

/* ‚îÄ‚îÄ Sticky UP NEXT Banner ‚îÄ‚îÄ */
.sticky-banner {
  position: fixed;
  top: 4px;
  left: 0;
  right: 0;
  z-index: 100;
  background: rgba(10, 22, 40, 0.95);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  border-bottom: 1px solid rgba(114, 155, 209, 0.3);
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
  padding: 10px 16px;
  font-size: 13px;
  color: #fff;
  text-align: center;
  line-height: 1.4;
  opacity: 0;
  transform: translateY(-10px);
  animation: slideDown 0.5s ease 0.5s forwards;
}
@keyframes slideDown {
  to { opacity: 1; transform: translateY(0); }
}
.sticky-banner .banner-emoji {
  font-size: 16px;
  margin-right: 4px;
}
.sticky-banner .banner-name {
  font-family: 'Bebas Neue', sans-serif;
  font-size: 16px;
  letter-spacing: 0.5px;
  color: #729bd1;
  font-weight: 600;
}
.sticky-banner .banner-time,
.sticky-banner .banner-location {
  color: #8bb4e0;
  font-size: 12px;
}
.sticky-banner .banner-countdown {
  color: #fff;
  font-weight: 600;
  margin-left: 6px;
}

/* ‚îÄ‚îÄ Container ‚îÄ‚îÄ */
.container { max-width:560px; margin:0 auto; padding:0 16px; padding-top:60px; position:relative; z-index:1; }

/* ‚îÄ‚îÄ Hero ‚îÄ‚îÄ */
.hero { text-align:center; padding:40px 0 20px; opacity:0; transform:translateY(24px); animation:slideUp .8s ease .15s forwards; }
@keyframes slideUp {
to { opacity:1; transform:translateY(0); }
}
.hero-badge {
display:inline-block; padding:6px 24px;
background:rgba(200,16,46,.14); border:1px solid rgba(200,16,46,.3);
border-radius:30px; margin-bottom:14px;
}
.hero-badge span { font-size:12px; font-weight:700; letter-spacing:3px; text-transform:uppercase; color:#e8a0ad; }
.hero-title {
font-family:‚ÄòBebas Neue‚Äô,sans-serif;
font-size:clamp(52px,11vw,84px);
letter-spacing:4px; line-height:.92;
background:linear-gradient(135deg,#fff 0%,#729bd1 50%,#fff 100%);
background-size:200% auto;
-webkit-background-clip:text; -webkit-text-fill-color:transparent;
background-clip:text;
animation:shimmer 4s ease-in-out infinite;
}
@keyframes shimmer { 0%{background-position:-200% center} 100%{background-position:200% center} }
.hero-sub { font-family:‚ÄòDancing Script‚Äô,cursive; color:#c8102e; font-size:clamp(24px,5.5vw,36px); margin-top:4px; }
.hero-divider { display:flex; align-items:center; justify-content:center; gap:12px; margin-top:16px; }
.hero-divider .line { width:50px; height:1px; background:rgba(114,155,209,.4); }
.hero-divider span { font-size:13px; font-weight:600; color:#729bd1; letter-spacing:2px; text-transform:uppercase; }

.quote-box {
margin-top:20px; padding:14px 20px;
background:linear-gradient(135deg,rgba(114,155,209,.1),rgba(200,16,46,.08));
border-radius:14px; border:1px solid rgba(114,155,209,.15);
}
.quote-box p { font-family:‚ÄòDancing Script‚Äô,cursive; transition:opacity .5s ease; font-size:21px; color:#c8d8ef; }

.quote-box p.fading { opacity: 0; }

/* ‚îÄ‚îÄ Share Button ‚îÄ‚îÄ */
.share-btn {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  margin-top: 16px;
  padding: 8px 16px;
  background: rgba(114, 155, 209, 0.08);
  border: 1px solid rgba(114, 155, 209, 0.3);
  border-radius: 20px;
  color: #8bb4e0;
  font-family: 'Outfit', sans-serif;
  font-weight: 600;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.3s ease;
  letter-spacing: 0.5px;
  text-transform: uppercase;
}
.share-btn:hover {
  background: rgba(114, 155, 209, 0.15);
  border-color: #729bd1;
  transform: translateY(-1px);
}
.share-toast {
  position: fixed;
  top: 80px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(76, 175, 80, 0.95);
  color: #fff;
  padding: 10px 20px;
  border-radius: 20px;
  font-size: 13px;
  font-weight: 600;
  z-index: 101;
  opacity: 0;
  transition: opacity 0.3s ease;
  pointer-events: none;
}
.share-toast.show {
  opacity: 1;
}
/* ‚îÄ‚îÄ Progress ‚îÄ‚îÄ */
.progress-wrap { margin:8px 0 20px; opacity:0; animation:slideUp .7s ease .3s forwards; }
.progress-labels { display:flex; justify-content:space-between; font-size:12px; color:#8bb4e0; margin-bottom:4px; }
.progress-track { height:4px; background:rgba(255,255,255,.1); border-radius:2px; overflow:hidden; }
.progress-fill  { height:100%; background:linear-gradient(90deg,#729bd1,#c8102e); border-radius:2px; transition:width .5s ease; width:0; }

/* ‚îÄ‚îÄ Filters ‚îÄ‚îÄ */
.filters { display:flex; gap:8px; justify-content:center; flex-wrap:wrap; margin-bottom:24px; opacity:0; animation:slideUp .7s ease .4s forwards; }
.fbtn {
padding:8px 18px; border:2px solid rgba(114,155,209,.4); border-radius:25px;
background:rgba(114,155,209,.08); color:#8bb4e0;
font-family:‚ÄòOutfit‚Äô,sans-serif; font-weight:600; font-size:13px;
cursor:pointer; transition:all .3s ease; letter-spacing:.5px; text-transform:uppercase; white-space:nowrap;
}
.fbtn:hover { background:rgba(114,155,209,.2); border-color:#729bd1; transform:translateY(-1px); }
.fbtn.active { background:linear-gradient(135deg,#729bd1,#5a85c0); border-color:#729bd1; color:#fff; box-shadow:0 4px 15px rgba(114,155,209,.4); }

/* ‚îÄ‚îÄ Cards ‚îÄ‚îÄ */
.card-list { display:flex; flex-direction:column; gap:10px; padding-bottom:24px; }

.card {
background:rgba(255,255,255,.04); border-radius:16px; padding:16px 18px;
border:1px solid rgba(255,255,255,.08); border-left:4px solid var(--accent);
cursor:pointer; position:relative; overflow:hidden;
backdrop-filter:blur(10px); -webkit-backdrop-filter:blur(10px);
transition:all .3s ease;
opacity:0; animation:slideIn .5s ease var(--d) forwards;
}
@keyframes slideIn { from{opacity:0;transform:translateX(-20px)} to{opacity:1;transform:translateX(0)} }
.card:hover { background:rgba(255,255,255,.08); border-color:rgba(255,255,255,.15); transform:translateY(-2px); box-shadow:0 8px 30px rgba(0,0,0,.3); }
.card.checked { opacity:.45; }
.card.checked .dance-name { text-decoration:line-through; }

/* ‚îÄ‚îÄ UP NEXT indicator ‚îÄ‚îÄ */
.card.up-next {
  background:rgba(114,155,209,.15);
  border:2px solid #729bd1;
  box-shadow:0 0 20px rgba(114,155,209,.4), 0 8px 30px rgba(0,0,0,.3);
  animation:slideIn .5s ease var(--d) forwards, pulseGlow 2s ease-in-out infinite;
}
@keyframes pulseGlow {
  0%, 100% { box-shadow:0 0 20px rgba(114,155,209,.4), 0 8px 30px rgba(0,0,0,.3); }
  50% { box-shadow:0 0 30px rgba(114,155,209,.6), 0 8px 30px rgba(0,0,0,.3); }
}
@media (prefers-reduced-motion: reduce) {
  .card.up-next {
    animation: slideIn .5s ease var(--d) forwards;
  }
}
.up-next-badge {
  display:inline-block;
  padding:4px 10px;
  background:linear-gradient(135deg,#729bd1,#5a85c0);
  border-radius:8px;
  font-size:10px;
  font-weight:700;
  letter-spacing:1.5px;
  text-transform:uppercase;
  color:#fff;
  margin-left:6px;
}
.time-until {
  font-size:11px;
  color:#729bd1;
  font-weight:600;
  margin-left:8px;
}

.card-inner { display:flex; align-items:flex-start; gap:14px; }
.card-icon { font-size:28px; line-height:1; margin-top:2px; flex-shrink:0; transition:filter .3s; }
.card.checked .card-icon { filter:grayscale(1); }
.card-body { flex:1; min-width:0; }
.card-top { display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
.dance-name { font-family:‚ÄòBebas Neue‚Äô,sans-serif; font-size:22px; letter-spacing:1px; transition:color .3s; }
.card.checked .dance-name { color:#666; }
.type-tag {
font-size:10px; font-weight:700; letter-spacing:1.5px; padding:3px 8px;
border-radius:6px; text-transform:uppercase; line-height:1.2;
}
.card-meta { display:flex; gap:16px; margin-top:4px; font-size:13px; color:#8bb4e0; }
.card.checked .card-meta { color:#555; }
.checkbox {
width:26px; height:26px; border-radius:8px; flex-shrink:0;
border:2px solid rgba(255,255,255,.2); display:flex; align-items:center; justify-content:center;
font-size:14px; transition:all .2s; margin-top:4px;
}
.card.checked .checkbox { border-color:#4CAF50; background:rgba(76,175,80,.2); }

/* ‚îÄ‚îÄ Solo group ‚îÄ‚îÄ */
.solo-group {
background:linear-gradient(135deg,rgba(200,16,46,.06),rgba(200,16,46,.02));
border-radius:20px; border:1px solid rgba(200,16,46,.2); overflow:hidden;
backdrop-filter:blur(10px); -webkit-backdrop-filter:blur(10px);
opacity:0; animation:slideIn .5s ease var(--d) forwards;
}
.solo-header {
padding:16px 20px; cursor:pointer; display:flex; align-items:center; justify-content:space-between;
transition:background .3s;
}
.solo-header:hover { background:rgba(200,16,46,.08); }
.solo-header-left { display:flex; align-items:center; gap:10px; }
.solo-title { font-family:‚ÄòBebas Neue‚Äô,sans-serif; font-size:22px; letter-spacing:1px; color:#f0b0b8; }
.solo-sub { font-size:12px; color:#c88090; }
.solo-arrow { font-size:20px; transition:transform .3s; }
.solo-arrow.open { transform:rotate(180deg); }

.solo-grid {
display:grid; grid-template-columns:repeat(auto-fill,minmax(140px,1fr));
gap:8px; padding:0 16px 16px; max-height:0; overflow:hidden; transition:max-height .4s ease, padding .4s ease;
}
.solo-grid.open { max-height:600px; padding-bottom:16px; }

.solo-chip {
background:rgba(200,16,46,.08); border:1px solid rgba(200,16,46,.2);
border-radius:12px; padding:10px 12px; text-align:center;
transition:all .2s; cursor:pointer;
}
.solo-chip:hover { background:rgba(200,16,46,.15); transform:scale(1.03); }
.solo-chip.checked-chip { opacity:.4; }
.solo-chip.checked-chip .solo-name { text-decoration:line-through; color:#888 !important; }
.solo-name { font-weight:600; font-size:14px; color:#f0c0c8; }
.solo-time { font-size:11px; color:#c88090; margin-top:2px; }

/* ‚îÄ‚îÄ Notes ‚îÄ‚îÄ */
.notes-box {
background:rgba(255,152,0,.08); border:1px solid rgba(255,152,0,.2);
border-radius:14px; padding:14px 18px; margin-top:10px; font-size:12px; color:#FFB74D; line-height:1.5;
}
.notes-box.gold { background:rgba(255,215,0,.08); border-color:rgba(255,215,0,.2); color:#FFD54F; }
.notes-box p + p { margin-top:6px; }

/* ‚îÄ‚îÄ Footer ‚îÄ‚îÄ */
.footer { text-align:center; padding:20px 0 44px; border-top:1px solid rgba(114,155,209,.15); }
.footer-hearts { font-size:20px; margin-bottom:8px; }
.footer-go { font-family:‚ÄòDancing Script‚Äô,cursive; font-size:24px; color:#729bd1; }
.footer-copy { font-size:11px; color:rgba(255,255,255,.3); margin-top:8px; letter-spacing:1px; }
.footer-credit { font-family:'Dancing Script',cursive; font-size:14px; color:#729bd1; margin-top:10px; }

@media(max-width:500px){
.solo-grid { grid-template-columns:repeat(2,1fr); }
.filters { gap:6px; }
.fbtn { padding:6px 12px; font-size:11px; }
}
</style>

</head>
<body>

<!-- ‚îÄ‚îÄ Background stars (generated by JS) ‚îÄ‚îÄ -->

<div id="stars"></div>
<div id="floaters"></div>

<div class="stripe"></div>

<!-- ‚îÄ‚îÄ Sticky UP NEXT Banner ‚îÄ‚îÄ -->
<div class="sticky-banner" id="sticky-banner">
  <span class="banner-emoji">‚è≥</span>
  <span class="banner-name">Loading...</span>
</div>

<div class="container">

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê HERO ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

  <div class="hero">
    <div style="font-size:36px;margin-bottom:8px;opacity:.9">ü§†</div>
    <div class="hero-badge"><span>‚òÖ Lumberton High School ‚òÖ</span></div>
    <h1 class="hero-title">RAIDERETTES</h1>
    <p class="hero-sub">Competition Day Schedule</p>
    <div class="hero-divider">
      <div class="line"></div>
      <span>First Comp of the Season!</span>
      <div class="line"></div>
    </div>
    <div class="quote-box">
      <p id="quote-text">"Comp Ready ‚Äî Good Luck Rettes!" üåü</p>
    </div>
    <button class="share-btn" id="share-btn">
      üì§ <span>Share Schedule</span>
    </button>
  </div>

  <!-- Toast notification for share feedback -->
  <div class="share-toast" id="share-toast">‚úÖ Link copied!</div>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê PROGRESS ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

  <div class="progress-wrap">
    <div class="progress-labels">
      <span>‚úÖ Progress Tracker</span>
      <span id="prog-text">0 / 25 complete</span>
    </div>
    <div class="progress-track"><div class="progress-fill" id="prog-bar"></div></div>
  </div>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê FILTERS ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

  <div class="filters">
    <button class="fbtn active" data-filter="all">All</button>
    <button class="fbtn" data-filter="team">üé™ Team</button>
    <button class="fbtn" data-filter="solos">‚≠ê Solos</button>
    <button class="fbtn" data-filter="important">üìå Info</button>
  </div>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê SCHEDULE ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

  <div class="card-list" id="schedule"></div>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê FOOTER ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

  <div class="footer">
    <div class="footer-hearts">ü§çüíô‚ù§Ô∏è</div>
    <p class="footer-go">Go Rettes!</p>
    <p class="footer-copy">LUMBERTON RAIDERETTES ¬∑ COMP SEASON 2026</p>
    <p class="footer-credit">Built with ‚ù§Ô∏è by Raiderette Dad David Landry ¬∑ Alyson's #1 Fan</p>
  </div>
</div>

<script>
// ‚îÄ‚îÄ Data ‚îÄ‚îÄ
const COMP_DATE = new Date(2026, 1, 14); // February 14, 2026 (months are 0-indexed)

const SCHEDULE = [
  { time:"8:39 AM",  loc:"Auxiliary Gym",            dance:"Officer Contemporary", type:"team",   icon:"üíÉ" },
  { time:"9:40 AM",  loc:"Main Gym",                 dance:"Beetlejuice Novelty",  type:"team",   icon:"ü™≤" },
  { time:"10:24 AM", loc:"Auxiliary Gym",             dance:"Officer Pom",          type:"team",   icon:"üì£" },
  { time:"10:35‚Äì11:30 AM", loc:"Off-site", dance:"Team Lunch",     type:"break",  icon:"üçó" },
  { time:"12:15 PM", loc:"Main Gym",                 dance:"All That Jazz ‚Äì Open", type:"team",   icon:"üé∑" },
  { time:"12:45 PM", loc:"Auditorium", dance:"Alyson",      type:"solo", icon:"‚≠ê" },
  { time:"12:49 PM", loc:"Auditorium", dance:"Hailey",      type:"solo", icon:"‚≠ê" },
  { time:"12:53 PM", loc:"Auditorium", dance:"Emma",        type:"solo", icon:"‚≠ê" },
  { time:"12:57 PM", loc:"Auditorium", dance:"Taylor",      type:"solo", icon:"‚≠ê" },
  { time:"1:01 PM",  loc:"Auditorium", dance:"Riley",       type:"solo", icon:"‚≠ê" },
  { time:"1:05 PM",  loc:"Auditorium", dance:"Tyffanie",    type:"solo", icon:"‚≠ê" },
  { time:"1:09 PM",  loc:"Auditorium", dance:"Bella",       type:"solo", icon:"‚≠ê" },
  { time:"1:13 PM",  loc:"Auditorium", dance:"Gabriella",   type:"solo", icon:"‚≠ê" },
  { time:"1:17 PM",  loc:"Auditorium", dance:"Baylee",      type:"solo", icon:"‚≠ê" },
  { time:"1:21 PM",  loc:"Auditorium", dance:"Kate",        type:"solo", icon:"‚≠ê" },
  { time:"1:25 PM",  loc:"Auditorium", dance:"Addyson",     type:"solo", icon:"‚≠ê" },
  { time:"1:29 PM",  loc:"Auditorium", dance:"Jaidyn",      type:"solo", icon:"‚≠ê" },
  { time:"1:33 PM",  loc:"Auditorium", dance:"Kallye",      type:"solo", icon:"‚≠ê" },
  { time:"1:37 PM",  loc:"Auditorium", dance:"Addison K.",  type:"solo", icon:"‚≠ê" },
  { time:"3:10 PM",  loc:"Main Gym",       dance:"Backstreet",          type:"team",   icon:"üï∫" },
  { time:"4:31 PM",  loc:"Auxiliary Gym",   dance:"Officer Jazz",        type:"team",   icon:"üé∂" },
  { time:"4:45‚Äì5:00 PM", loc:"Dressing Rooms",  dance:"Vacate Rooms",        type:"info",   icon:"üö™" },
  { time:"5:00‚Äì8:30 PM", loc:"Off-site",    dance:"Dinner Break",        type:"break",  icon:"üçî" },
  { time:"8:30 PM",  loc:"TBD",             dance:"Directors Meeting",   type:"info",   icon:"üìã" },
  { time:"8:50‚Äì9:45 PM", loc:"Main Gym",           dance:"Awards Ceremony",     type:"awards", icon:"üèÜ" },
];

const TOTAL = SCHEDULE.length;
let checked = {};
let currentFilter = "all";
let solosOpen = false;

// ‚îÄ‚îÄ Try to restore checked state from URL hash ‚îÄ‚îÄ
try {
  if (location.hash.length > 1) {
    const raw = atob(location.hash.slice(1));
    checked = JSON.parse(raw);
  }
} catch(e) {}

// ‚îÄ‚îÄ Stars ‚îÄ‚îÄ
const starsEl = document.getElementById("stars");
for (let i = 0; i < 30; i++) {
  const s = document.createElement("div");
  s.className = "star";
  s.style.top = Math.random()*100+"%";
  s.style.left = Math.random()*100+"%";
  s.style.setProperty("--dur", (2+Math.random()*3)+"s");
  s.style.setProperty("--delay", (Math.random()*4)+"s");
  starsEl.appendChild(s);
}

// ‚îÄ‚îÄ Floaters ‚îÄ‚îÄ
const floatEl = document.getElementById("floaters");
["üíÉ","‚≠ê","üéµ","‚ú®","ü§†","üë¢","üé∂","üí´"].forEach(e => {
  const f = document.createElement("div");
  f.className = "floater";
  f.textContent = e;
  f.style.top = (10+Math.random()*80)+"%";
  f.style.left = Math.random()*100+"%";
  f.style.setProperty("--dur", (8+Math.random()*6)+"s");
  f.style.setProperty("--delay", (Math.random()*5)+"s");
  floatEl.appendChild(f);
});

// ‚îÄ‚îÄ Motivational Quotes ‚îÄ‚îÄ
const QUOTES = [
  "\"Comp Ready ‚Äî Good Luck Rettes!\" üåü",
  "\"Leave it all on the floor!\" üíÉ",
  "\"You've trained for this moment!\" ‚≠ê",
  "\"Dance like nobody's watching!\" üé∂",
  "\"Trust your training, own that stage!\" üî•",
  "\"Shoulders back, chin up, let's GO!\" üí™",
  "\"This is YOUR moment ‚Äî make it count!\" ‚ú®",
  "\"Together we shine brighter!\" üí´"
];

const QUOTE_ROTATION_INTERVAL_MS = 18000; // 18 seconds
const FADE_DURATION_MS = 500; // Must match CSS transition duration

let currentQuoteIndex = Math.floor(Math.random() * QUOTES.length);
const quoteText = document.getElementById("quote-text");

// Set initial random quote
if (quoteText) {
  quoteText.textContent = QUOTES[currentQuoteIndex];
}

// Rotate quotes every 18 seconds
function rotateQuote() {
  if (!quoteText) return;

  // Fade out
  quoteText.classList.add("fading");

  setTimeout(() => {
    // Change quote
    currentQuoteIndex = (currentQuoteIndex + 1) % QUOTES.length;
    quoteText.textContent = QUOTES[currentQuoteIndex];

    // Fade in
    quoteText.classList.remove("fading");
  }, FADE_DURATION_MS);
}

// Start/pause quote rotation based on page visibility to save battery
let quoteRotationIntervalId = null;

function startQuoteRotation() {
  if (quoteRotationIntervalId === null && !document.hidden) {
    quoteRotationIntervalId = setInterval(rotateQuote, QUOTE_ROTATION_INTERVAL_MS);
  }
}

function stopQuoteRotation() {
  if (quoteRotationIntervalId !== null) {
    clearInterval(quoteRotationIntervalId);
    quoteRotationIntervalId = null;
  }
}

// Initialize quote rotation only when page is visible
if (!document.hidden) {
  startQuoteRotation();
}

// Pause/resume quote rotation when tab visibility changes
document.addEventListener("visibilitychange", () => {
  if (document.hidden) {
    stopQuoteRotation();
  } else {
    startQuoteRotation();
  }
});
// ‚îÄ‚îÄ Share Button ‚îÄ‚îÄ
const shareBtn = document.getElementById("share-btn");
const shareToast = document.getElementById("share-toast");

if (shareBtn) {
  shareBtn.addEventListener("click", async () => {
    // Prevent re-entrancy if a share is already in progress
    if (shareBtn.disabled) return;

    const url = window.location.href;
    const originalText = shareBtn.textContent;

    // Disable button and show loading state
    shareBtn.disabled = true;
    shareBtn.textContent = "Sharing...";

    try {
      let shared = false;
      
      // Try native share API first (mobile)
      if (navigator.share) {
        try {
          await navigator.share({
            title: 'Raiderettes Competition Schedule',
            text: 'Check out the Raiderettes competition day schedule!',
            url: url
          });
          shared = true;
        } catch (err) {
          // User cancelled or share failed, fall back to clipboard
          if (err.name !== 'AbortError') {
            console.error('Share failed:', err);
          }
        }
      }
      
      // Fallback to clipboard if native share didn't succeed
      if (!shared) {
        try {
          await navigator.clipboard.writeText(url);
          
          // Show toast
          if (shareToast) {
            shareToast.classList.add("show");
            setTimeout(() => {
              shareToast.classList.remove("show");
            }, 2000);
          }
        } catch (err) {
          console.error('Copy failed:', err);
          // Show error toast if clipboard fails
          if (shareToast) {
            shareToast.textContent = '‚ùå Copy failed';
            shareToast.style.background = 'rgba(244, 67, 54, 0.95)';
            shareToast.classList.add("show");
            setTimeout(() => {
              shareToast.classList.remove("show");
              // Reset toast content and color
              setTimeout(() => {
                shareToast.textContent = '‚úÖ Link copied!';
                shareToast.style.background = 'rgba(76, 175, 80, 0.95)';
              }, 300);
            }, 2000);
          }
        }
      }
    } finally {
      // Re-enable button and restore original text
      shareBtn.disabled = false;
      shareBtn.textContent = originalText;
    }
  });
}

// ‚îÄ‚îÄ Helpers ‚îÄ‚îÄ
const typeColor = t => ({
  team:   { bg:"rgba(114,155,209,.15)", brd:"#729bd1", acc:"#729bd1" },
  solo:   { bg:"rgba(200,16,46,.08)",   brd:"#c8102e", acc:"#c8102e" },
  break:  { bg:"rgba(76,175,80,.1)",    brd:"#4CAF50", acc:"#4CAF50" },
  info:   { bg:"rgba(255,152,0,.1)",    brd:"#FF9800", acc:"#FF9800" },
  awards: { bg:"rgba(255,215,0,.15)",   brd:"#FFD700", acc:"#DAA520" },
}[t] || { bg:"rgba(114,155,209,.1)", brd:"#729bd1", acc:"#729bd1" });

const typeLabel = t => ({ team:"TEAM", solo:"SOLO", break:"BREAK", info:"INFO", awards:"AWARDS" }[t] || "");

// ‚îÄ‚îÄ Convert 12-hour time to 24-hour format ‚îÄ‚îÄ
function convertTo24Hour(hours, period) {
  hours = parseInt(hours);
  const p = period.toUpperCase();
  if (p === 'PM' && hours < 12) return hours + 12;
  if (p === 'AM' && hours === 12) return 0;
  return hours;
}

// ‚îÄ‚îÄ Parse time string to today's Date object ‚îÄ‚îÄ
function parseScheduleTime(timeStr) {
  // Handle formats like "8:39 AM", "12:15 PM", "10:35‚Äì11:30 AM" (use start time)
  let timeMatch = timeStr.match(/^(\d{1,2}):(\d{2})\s*(AM|PM)/i);
  
  if (!timeMatch) {
    // Try range format: "10:35‚Äì11:30 AM"
    const rangeMatch = timeStr.match(/^(\d{1,2}):(\d{2})‚Äì.+?(AM|PM)/i);
    if (rangeMatch) {
      timeMatch = rangeMatch;
    }
  }
  
  if (!timeMatch) return null;
  
  const [, hoursStr, minutes, period] = timeMatch;
  const hours = convertTo24Hour(hoursStr, period);
  
  const eventTime = new Date(COMP_DATE.getFullYear(), COMP_DATE.getMonth(), COMP_DATE.getDate(), hours, parseInt(minutes), 0);
  
  return eventTime;
}

// ‚îÄ‚îÄ Find current or next event ‚îÄ‚îÄ
function findUpNextEvent() {
  const now = new Date();
  
  // Parse all times
  const eventsWithTime = SCHEDULE.map((item, idx) => ({
    ...item,
    idx,
    parsedTime: parseScheduleTime(item.time)
  })).filter(e => e.parsedTime !== null);
  
  // Find first event that hasn't started yet
  const upcomingEvents = eventsWithTime.filter(e => e.parsedTime > now);
  
  if (upcomingEvents.length > 0) {
    // Return the next upcoming event
    return { ...upcomingEvents[0], isNow: false };
  }
  
  // Check for exact-time events that are currently happening (e.g., solos)
  // Iterate backwards through events to find the most recent one
  for (let i = eventsWithTime.length - 1; i >= 0; i--) {
    const event = eventsWithTime[i];
    
    // Skip future events
    if (event.parsedTime > now) continue;
    
    const timeStr = event.time;
    
    // Check if it's an exact time (not a range)
    const isExactTime = !timeStr.includes('‚Äì') && !timeStr.includes('-');
    
    if (isExactTime) {
      // For exact times, treat as ongoing for 4 minutes or until the next event starts
      const eventEndTime = new Date(event.parsedTime.getTime() + 4 * 60 * 1000); // 4 minutes later
      
      // Check if there's a next event (look ahead in the array)
      const nextEvent = i + 1 < eventsWithTime.length ? eventsWithTime[i + 1] : null;
      const nextEventTime = nextEvent ? nextEvent.parsedTime : null;
      
      // If next event starts before 4 minutes, use that as the end time
      const actualEndTime = nextEventTime && nextEventTime < eventEndTime ? nextEventTime : eventEndTime;
      
      if (now < actualEndTime) {
        return { ...event, isNow: true };
      }
    }
  }
  
  // Check if we're during an event (for ranges)
  const ongoingEvents = eventsWithTime.filter(e => {
    const timeStr = e.time;
    const rangeMatch = timeStr.match(/^(\d{1,2}):(\d{2})\s*(AM|PM)\s*[‚Äì-]\s*(\d{1,2}):(\d{2})(?:\s*(AM|PM))?/i);
    if (rangeMatch) {
      const [, startHoursStr, startMinutes, startPeriod, endHoursStr, endMinutes, endPeriod] = rangeMatch;
      
      // Use end period if provided, otherwise use start period
      let effectiveEndPeriod = endPeriod || startPeriod;
      
      // If no explicit end period and end hour is less than start hour, flip the period
      if (!endPeriod) {
        const startHourNum = parseInt(startHoursStr);
        const endHourNum = parseInt(endHoursStr);
        if (endHourNum < startHourNum) {
          effectiveEndPeriod = startPeriod.toUpperCase() === 'AM' ? 'PM' : 'AM';
        }
      }
      
      const startH = convertTo24Hour(startHoursStr, startPeriod);
      const endH = convertTo24Hour(endHoursStr, effectiveEndPeriod);
      
      const startTime = new Date(COMP_DATE.getFullYear(), COMP_DATE.getMonth(), COMP_DATE.getDate(), startH, parseInt(startMinutes), 0);
      const endTime = new Date(COMP_DATE.getFullYear(), COMP_DATE.getMonth(), COMP_DATE.getDate(), endH, parseInt(endMinutes), 0);
      
      return now >= startTime && now < endTime;
    }
    return false;
  });
  
  if (ongoingEvents.length > 0) {
    return { ...ongoingEvents[0], isNow: true };
  }
  
  // All events are in the past - return null
  return null;
}

// ‚îÄ‚îÄ Format time until event ‚îÄ‚îÄ
function formatTimeUntil(eventTime) {
  const now = new Date();
  const diff = eventTime - now;
  
  if (diff < 0) return "now";
  
  const minutes = Math.floor(diff / 60000);
  const hours = Math.floor(minutes / 60);
  const remainingMinutes = minutes % 60;
  
  if (hours > 0) {
    if (remainingMinutes > 0) {
      return `in ${hours} hr${hours > 1 ? 's' : ''} ${remainingMinutes} min`;
    }
    return `in ${hours} hr${hours > 1 ? 's' : ''}`;
  }
  
  return `in ${minutes} min`;
}

function updateProgress() {
  const n = Object.values(checked).filter(Boolean).length;
  document.getElementById("prog-text").textContent = n + " / " + TOTAL + " complete";
  document.getElementById("prog-bar").style.width = (n/TOTAL*100)+"%";
  // Save to hash
  try { location.hash = btoa(JSON.stringify(checked)); } catch(e){}
}

function toggleCheck(idx) {
  checked[idx] = !checked[idx];
  updateProgress();
  
  // Update only the specific card/chip instead of full re-render
  const item = SCHEDULE[idx];
  
  if (item.type === "solo") {
    // Update solo chip
    const chip = document.querySelector(`.solo-chip[data-sidx="${idx}"]`);
    if (chip) {
      if (checked[idx]) {
        chip.classList.add("checked-chip");
      } else {
        chip.classList.remove("checked-chip");
      }
    }
    
    // Update solo group counter
    const soloSub = document.querySelector(".solo-sub");
    if (soloSub) {
      const visible = SCHEDULE.map((item, i) => ({ ...item, idx: i })).filter(item => {
        if (currentFilter === "all") return true;
        if (currentFilter === "team") return item.type === "team";
        if (currentFilter === "solos") return item.type === "solo";
        if (currentFilter === "important") return ["break","info","awards"].includes(item.type);
        return true;
      });
      const solos = visible.filter(i => i.type === "solo");
      const soloChecked = solos.filter(s => checked[s.idx]).length;
      soloSub.textContent = `12:45 ‚Äì 1:37 PM ¬∑ Auditorium ¬∑ ${solos.length} dancers ¬∑ ${soloChecked} done`;
    }
  } else {
    // Update regular card
    const card = document.querySelector(`.card[data-idx="${idx}"]`);
    if (card) {
      const checkbox = card.querySelector(".checkbox");
      if (checked[idx]) {
        card.classList.add("checked");
        if (checkbox) checkbox.textContent = "‚úì";
      } else {
        card.classList.remove("checked");
        if (checkbox) checkbox.textContent = "";
      }
    }
  }
}

// ‚îÄ‚îÄ Filters ‚îÄ‚îÄ
document.querySelectorAll(".fbtn").forEach(btn => {
  btn.addEventListener("click", () => {
    document.querySelectorAll(".fbtn").forEach(b => b.classList.remove("active"));
    btn.classList.add("active");
    currentFilter = btn.dataset.filter;
    
    // Auto-expand solos when filtering to solos, collapse when switching away
    if (currentFilter === "solos") {
      solosOpen = true;
    } else {
      solosOpen = false;
    }
    
    render();
  });
});

// ‚îÄ‚îÄ Notes HTML ‚îÄ‚îÄ
function notesFor(dance) {
  if (dance === "Vacate Rooms") return `<div class="notes-box"><p>‚ö†Ô∏è Team released after Director inspects the room. Take ALL belongings &amp; chairs out of dressing rooms to vehicles.</p></div>`;
  if (dance === "Team Lunch") return `<div class="notes-box"><p>üçΩÔ∏è Chick-fil-A / Jersey Mike's ‚Äî Be back and ready by 12:00 PM</p></div>`;
  if (dance === "Dinner Break") return `<div class="notes-box"><p>üçΩÔ∏è Be back to meet Directors by 8:30 PM</p></div>`;
  if (dance === "Directors Meeting") return `<div class="notes-box"><p>‚ö†Ô∏è Meet Directors at 8:30 ‚Äî Do <strong>NOT</strong> be late!</p></div>`;
  if (dance === "Awards Ceremony") return `<div class="notes-box gold"><p>üèÜ Wear your team pant set! Competition can run ahead or behind schedule ‚Äî please be flexible.</p><p>üí´ Rettes will be dismissed after Awards and Team Pictures.</p></div>`;
  return "";
}

// ‚îÄ‚îÄ Render ‚îÄ‚îÄ
function render() {
  const list = document.getElementById("schedule");
  list.innerHTML = "";

  const visible = SCHEDULE.map((item, i) => ({ ...item, idx: i })).filter(item => {
    if (currentFilter === "all") return true;
    if (currentFilter === "team") return item.type === "team";
    if (currentFilter === "solos") return item.type === "solo";
    if (currentFilter === "important") return ["break","info","awards"].includes(item.type);
    return true;
  });

  const solos = visible.filter(i => i.type === "solo");
  const hasRenderedSolos = { done: false };
  let cardIdx = 0;
  
  // Find up next event
  const upNextEvent = findUpNextEvent();
  const upNextIdx = upNextEvent ? upNextEvent.idx : -1;

  visible.forEach(item => {
    // ‚îÄ‚îÄ Solo group ‚îÄ‚îÄ
    if (item.type === "solo") {
      if (hasRenderedSolos.done) return;
      hasRenderedSolos.done = true;

      const soloChecked = solos.filter(s => checked[s.idx]).length;
      const grp = document.createElement("div");
      grp.className = "solo-group";
      grp.style.setProperty("--d", (.35 + cardIdx * .06) + "s");
      cardIdx++;

      grp.innerHTML = `
        <div class="solo-header" id="solo-toggle">
          <div class="solo-header-left">
            <span style="font-size:24px">‚≠ê</span>
            <div>
              <div class="solo-title">Solo Performances</div>
              <div class="solo-sub">12:45 ‚Äì 1:37 PM ¬∑ Auditorium ¬∑ ${solos.length} dancers ¬∑ ${soloChecked} done</div>
            </div>
          </div>
          <span class="solo-arrow ${solosOpen?'open':''}">‚ñæ</span>
        </div>
        <div class="solo-grid ${solosOpen?'open':''}" id="solo-grid">
          ${solos.map((s, soloIdx) => `
            <div class="solo-chip ${checked[s.idx]?'checked-chip':''}" data-sidx="${s.idx}">
              <div class="solo-name">#${soloIdx + 1} ${s.dance}</div>
              <div class="solo-time">${s.time}</div>
            </div>
          `).join("")}
        </div>
      `;

      grp.querySelector("#solo-toggle").addEventListener("click", () => {
        solosOpen = !solosOpen;
        render();
      });

      grp.querySelectorAll(".solo-chip").forEach(chip => {
        chip.addEventListener("click", e => {
          e.stopPropagation();
          toggleCheck(parseInt(chip.dataset.sidx));
        });
      });

      list.appendChild(grp);
      return;
    }

    // ‚îÄ‚îÄ Regular card ‚îÄ‚îÄ
    const c = typeColor(item.type);
    const isChecked = !!checked[item.idx];
    const isUpNext = item.idx === upNextIdx;
    const isNow = upNextEvent && upNextEvent.isNow && item.idx === upNextIdx;
    const card = document.createElement("div");
    card.className = "card" + (isChecked ? " checked" : "") + (isUpNext ? " up-next" : "");
    card.dataset.idx = item.idx;
    card.style.setProperty("--accent", c.brd);
    card.style.setProperty("--d", (.35 + cardIdx * .06) + "s");
    cardIdx++;
    
    // Build time until text and badge
    let timeUntilHTML = "";
    let badgeHTML = "";
    if (isUpNext) {
      if (isNow) {
        badgeHTML = '<span class="up-next-badge">üî¥ NOW</span>';
        timeUntilHTML = '<span class="time-until">happening now</span>';
      } else if (upNextEvent && upNextEvent.parsedTime) {
        badgeHTML = '<span class="up-next-badge">‚è≥ UP NEXT</span>';
        const timeUntilText = formatTimeUntil(upNextEvent.parsedTime);
        timeUntilHTML = `<span class="time-until">${timeUntilText}</span>`;
      }
    }

    card.innerHTML = `
      <div class="card-inner">
        <div class="card-icon">${item.icon}</div>
        <div class="card-body">
          <div class="card-top">
            <span class="dance-name">${item.dance}</span>
            <span class="type-tag" style="background:${c.bg};color:${c.acc};border:1px solid ${c.brd}40">${typeLabel(item.type)}</span>
            ${badgeHTML}
            ${timeUntilHTML}
          </div>
          <div class="card-meta">
            <span>üïê ${item.time}</span>
            <span>üìç ${item.loc}</span>
          </div>
        </div>
        <div class="checkbox">${isChecked ? "‚úì" : ""}</div>
      </div>
      ${notesFor(item.dance)}
    `;

    card.addEventListener("click", () => toggleCheck(item.idx));
    list.appendChild(card);
  });
}

// ‚îÄ‚îÄ Init ‚îÄ‚îÄ
updateProgress();
render();

// ‚îÄ‚îÄ Update Sticky Banner ‚îÄ‚îÄ
function updateStickyBanner() {
  const banner = document.getElementById("sticky-banner");
  if (!banner) return;
  
  const upNextEvent = findUpNextEvent();
  
  if (!upNextEvent) {
    // All events are over
    banner.innerHTML = '<span class="banner-emoji">üéâ</span> <span class="banner-name">All done! Great job Rettes!</span>';
    return;
  }
  
  const item = SCHEDULE[upNextEvent.idx];
  const isNow = upNextEvent.isNow;
  
  let emoji, prefix, timeDisplay, countdownText;
  
  if (isNow) {
    emoji = 'üî¥';
    prefix = 'NOW';
    timeDisplay = item.time;
    countdownText = '';
  } else {
    emoji = '‚è≥';
    prefix = 'UP NEXT';
    timeDisplay = item.time;
    if (upNextEvent.parsedTime) {
      const timeUntil = formatTimeUntil(upNextEvent.parsedTime);
      countdownText = ` ¬∑ <span class="banner-countdown">${timeUntil}</span>`;
    } else {
      countdownText = '';
    }
  }
  
  banner.innerHTML = `
    <span class="banner-emoji">${emoji}</span>
    <span class="banner-name">${prefix}: ${item.dance}</span>
    <span class="banner-time"> ¬∑ ${timeDisplay}</span>
    <span class="banner-location"> ¬∑ ${item.loc}</span>${countdownText}
  `;
}

// Call initially
updateStickyBanner();

// ‚îÄ‚îÄ Auto-update UP NEXT with targeted updates and Page Visibility API ‚îÄ‚îÄ
let updateIntervalId = null;
let lastUpNextIdx = -1;

function updateUpNext() {
  const upNextEvent = findUpNextEvent();
  const newUpNextIdx = upNextEvent ? upNextEvent.idx : -1;
  
  // Update sticky banner
  updateStickyBanner();
  
  // If all events are past, stop the interval and do a final render
  if (newUpNextIdx === -1) {
    if (updateIntervalId !== null) {
      clearInterval(updateIntervalId);
      updateIntervalId = null;
    }
    lastUpNextIdx = -1;
    render();
    return;
  }
  
  // If the up-next event has changed, do a full render
  if (newUpNextIdx !== lastUpNextIdx) {
    lastUpNextIdx = newUpNextIdx;
    render();
  } else {
    // Otherwise, just update the time-until text on the current UP NEXT card
    const card = document.querySelector(`.card.up-next`);
    if (card && upNextEvent && upNextEvent.parsedTime) {
      const timeUntilEl = card.querySelector('.time-until');
      if (timeUntilEl && !upNextEvent.isNow) {
        const timeUntilText = formatTimeUntil(upNextEvent.parsedTime);
        timeUntilEl.textContent = timeUntilText;
      }
    }
  }
}

function startUpdateInterval() {
  if (updateIntervalId === null) {
    // Align lastUpNextIdx with the current up-next event to avoid an extra full render
    const initialUpNextEvent = findUpNextEvent();
    lastUpNextIdx = initialUpNextEvent ? initialUpNextEvent.idx : -1;

    // Run immediately on start (will now usually do a lightweight update only)
    updateUpNext();

    // Then run every 30 seconds while there are upcoming events
    if (lastUpNextIdx !== -1) {
      updateIntervalId = setInterval(updateUpNext, 30000);
    }
  }
}

function stopUpdateInterval() {
  if (updateIntervalId !== null) {
    clearInterval(updateIntervalId);
    updateIntervalId = null;
  }
}

// Use Page Visibility API to pause/resume updates
document.addEventListener("visibilitychange", () => {
  if (document.hidden) {
    stopUpdateInterval();
  } else {
    startUpdateInterval();
  }
});

// Start the update interval
startUpdateInterval();

</script>

</body>
</html>